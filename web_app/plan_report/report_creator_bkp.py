import os

os.environ['ETS_TOOLKIT'] = 'wx'
import dicom
import numpy as np

# Needed for Mayavi 3d rendering
from matplotlib.path import Path
from mayavi import mlab

# Needed for creating the pdf report
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen.canvas import Canvas
from reportlab.lib.units import inch

import sys

if sys.version[0] == '2':
    import cStringIO

    output = cStringIO.StringIO()
else:
    # python3.4
    from io import StringIO

    output = StringIO()


#######################################################################
##### Main program
class ReportCreator():
    def __init__(self):
        mlab.options.offscreen = True
        # pass

    # Create and save the images from 6 views
    def makeReport(self):
        res = 512  # Resolution of image. Currently using 270x270 for speed.
        curView = mlab.view()  # Get the current camera orientation
        distance = curView[2] * 0.7  # We're mostly interested in the distance (zoom)
        curPosition, curFoc = mlab.move()  # Get the current camera Position (we only want focal point)

        # The six views are generated by rotating the camera
        # The distance (zoom) and focal point of the user's view is perserved
        mlab.view(45, 90, distance, curFoc)
        mlab.savefig('BackLeft.png', size=(res, res))
        mlab.view(90, 90, distance, curFoc)
        mlab.savefig('Back.png', size=(res, res))
        mlab.view(135, 90, distance, curFoc)
        mlab.savefig('BackRight.png', size=(res, res))
        mlab.view(315, 90, distance, curFoc)
        mlab.savefig('FrontLeft.png', size=(res, res))
        mlab.view(270, 90, distance, curFoc)
        mlab.savefig('Front.png', size=(res, res))
        mlab.view(225, 90, distance, curFoc)
        mlab.savefig('FrontRight.png', size=(res, res))

        return self.createPDF(0)  # 0 is parameter for report with big image

    # Load a struct file only. Code is similar to loadFolder()
    def loadStruct(self, filename):
        self.structFile = dicom.read_file(filename)
        if "StructureSetROISequence" in self.structFile:
            self.roiList = [roi.ROIName for roi in self.structFile.StructureSetROISequence if "ROIName" in roi]
        else:
            return "Not an RTStruct file"
        return 0

    # Load a dose file only. Code is similar to loadFolder()
    def loadDose(self, filenames):
        self.doseFile = dicom.read_file(filenames[0])

        if len(filenames) == 1:
            self.dosePixels = self.doseFile.pixel_array * self.doseFile.DoseGridScaling
        else:
            try:
                self.dosePixels = self.getSumDose(filenames)
            except ValueError:
                return "Dose grids must have the same dimensions"
        return 0

    def set_ctfile(self, filename):
        self.ctFile = filename

    def getSumDose(self, filenames):
        # Use first dose file's coordinate system
        dose_file = self.doseFile
        dose_grid = dose_file.pixel_array * dose_file.DoseGridScaling
        for dose_filename in filenames[1:]:
            sum_dose_file = dicom.read_file(dose_filename)
            dose_grid += sum_dose_file.pixel_array * sum_dose_file.DoseGridScaling

        return dose_grid

    # Generate a 3D model based on selected ROIs
    def loadModel(self, roi_numbers):
        self.roiName = self.roiList[roi_numbers[0]]

        for roi_num in roi_numbers:
            roiContours = self.structFile.ROIContourSequence[roi_num]
            if "Contours" not in roiContours:
                print("No contours found in roi_numbers")
                return

        zSpacing = abs(self.doseFile.GridFrameOffsetVector[1] - self.doseFile.GridFrameOffsetVector[0])
        firstZ = self.doseFile.ImagePositionPatient[2] - 0.5 * zSpacing

        structDict = {}
        structDict["contours"] = {}
        xArray = []
        yArray = []
        zArray = []

        # Get contour data for each roi_numbers
        for roi_num in roi_numbers:
            roiContours = self.structFile.ROIContourSequence[roi_num]
            for aContour in roiContours.ContourSequence:
                sliceNumber = int(round((aContour.ContourData[2] - firstZ) / zSpacing))
                if sliceNumber not in structDict["contours"]:
                    structDict["contours"][sliceNumber] = []
                curContour = np.array(aContour.ContourData).reshape(-1, 3)[:, 0:2]
                structDict["contours"][sliceNumber].append(Path(curContour))
                curContour = np.array(aContour.ContourData).reshape(-1, 3)
                xArray += list(curContour[:, 0])
                yArray += list(curContour[:, 1])
                zArray += list(curContour[:, 2])

        xSpacing = self.doseFile.PixelSpacing[0]
        ySpacing = self.doseFile.PixelSpacing[1]

        firstX = self.doseFile.ImagePositionPatient[0] - 0.5 * xSpacing
        firstY = self.doseFile.ImagePositionPatient[1] - 0.5 * ySpacing

        numX = self.doseFile.Columns
        numY = self.doseFile.Rows

        indices = np.indices((numY, numX))  # Not sure why indices are Y,X instead of X,Y
        xPositions = indices[1] * xSpacing + firstX
        yPositions = indices[0] * ySpacing + firstY
        positions = np.array(zip(xPositions.flatten(), yPositions.flatten()))

        doseMatrix = np.zeros(self.dosePixels.shape)
        for aSlice in structDict["contours"]:
            if aSlice < doseMatrix.shape[0]:
                for aContour in structDict["contours"][aSlice]:
                    result = aContour.contains_points(positions)
                    result = np.resize(result, self.dosePixels[aSlice].shape)
                    doseMatrix[aSlice] += self.dosePixels[aSlice] * result

        # doseMatrix = doseMatrix * self.doseFile.DoseGridScaling
        self.maxStructDose = doseMatrix.max()

        mlab.clf()
        doseValues = [self.getDoseValue(aPoint[0], aPoint[1], aPoint[2]) for aPoint in zip(xArray, yArray, zArray)]
        volume = mlab.points3d(xArray, yArray, zArray, doseValues, scale_mode="none")
        # mlab.title('Patient: %s' % patientName)
        mlab.colorbar(volume, "Dose (Gy)", nb_labels=4, orientation="horizontal", label_fmt="%2.0f")
        lut = volume.module_manager.scalar_lut_manager.lut
        lut.range = [0, self.maxStructDose]
        # self.drawSkin()     # Draw the patient body

    def getDoseValue(self, x, y, z):
        xVoxel = (x - self.doseFile.ImagePositionPatient[0]) / self.doseFile.PixelSpacing[0]
        yVoxel = (y - self.doseFile.ImagePositionPatient[1]) / self.doseFile.PixelSpacing[1]
        zSlice = (z - self.doseFile.ImagePositionPatient[2]) / (
            abs(self.doseFile.GridFrameOffsetVector[1] - self.doseFile.GridFrameOffsetVector[0]))
        if xVoxel < self.doseFile.Columns and yVoxel < self.doseFile.Rows and zSlice < len(
                self.doseFile.GridFrameOffsetVector):
            return self.dosePixels[zSlice][yVoxel][xVoxel]
        else:
            return 0

    def drawSkin(self):
        ROI = 'EXTERNAL'  # Making a guess here in assuming all body ROIs have the name 'BODY'

        # The steps are similar to loadModel(), except simpler since ROI is no longer a list
        index = self.roiList.index(ROI)
        zSpacing = abs(self.doseFile.GridFrameOffsetVector[1] - self.doseFile.GridFrameOffsetVector[0])
        firstZ = self.doseFile.ImagePositionPatient[2] - 0.5 * zSpacing

        roiContours = self.structFile.ROIContourSequence[index]
        # This should be unncessary, but it's still here for now
        if "Contours" not in roiContours:
            print("No contours found in ROI")
            return

        structDict = {}
        structDict["contours"] = {}
        xArray = []
        yArray = []
        zArray = []

        for aContour in roiContours.ContourSequence:
            sliceNumber = int(round((aContour.ContourData[2] - firstZ) / zSpacing))
            if sliceNumber not in structDict["contours"]:
                structDict["contours"][sliceNumber] = []
            curContour = np.array(aContour.ContourData).reshape(-1, 3)[:, 0:2]
            structDict["contours"][sliceNumber].append(Path(curContour))
            curContour = np.array(aContour.ContourData).reshape(-1, 3)
            xArray += list(curContour[:, 0])
            yArray += list(curContour[:, 1])
            zArray += list(curContour[:, 2])

        mlab.plot3d(xArray, yArray, zArray, color=(0, 0, 0))

    def createPDF(self, imageOrientation=1):
        # python3.4
        # from io import StringI
        # output = StringIO()
        # Python 2.7
        # import cStringIO
        # output = cStringIO.StringIO()

        # Create the PDF canvas
        c = Canvas(output, pagesize=letter)

        # Get some relevant variables
        patientName = self.doseFile.PatientName
        patientID = self.doseFile.PatientID

        structName = self.roiName
        structMaxDose = 'Max Dose to structure: %0.2f Gy' % self.maxStructDose
        maxDose = 'Max Dose to whole volume: %0.2f Gy' % (self.dosePixels.max())

        ctDicom = dicom.read_file(self.ctFile)
        hospitalName = ctDicom.InstitutionName
        doctorName = ctDicom.ReferringPhysicianName

        # Size of letter
        width, height = letter
        # Point of origin for reportlab is bottom left of page

        lineSpacing = 12

        if imageOrientation == 1:  # "Small images" option
            c.setLineWidth(.5)
            c.setFont('Helvetica', 12)

            # Use 1 inch margins
            startX = height - inch
            startY = inch

            midPosition = (startY + (width - inch)) / 2  # The midline of the page

            # Top left text of the page (Patient Info)
            c.drawString(startY, startX, 'Patient:')
            c.drawString(startY, startX - lineSpacing, patientName)
            c.drawString(startY, startX - 2 * lineSpacing, patientID)

            # Top middle text of the page (ROI info)
            c.drawCentredString(midPosition, startX, structName)
            c.drawCentredString(midPosition, startX - lineSpacing, structMaxDose)
            c.drawCentredString(midPosition, startX - 2 * lineSpacing, maxDose)

            # Top right text of the page (Institution/Doctor name)
            c.drawRightString(width - inch, startX, hospitalName)
            c.drawRightString(width - inch, startX - lineSpacing, doctorName)

            # Draw a line to seperate text from images
            c.line(startY, startX - 3 * lineSpacing, width - inch, startX - 3 * lineSpacing)

            # Draw the images
            c.drawImage('FrontLeft.png', startY, startX - 3 * lineSpacing - 2.25 * inch, width=2 * inch,
                        height=2 * inch)
            c.drawImage('Front.png', startY + 2.25 * inch, startX - 3 * lineSpacing - 2.25 * inch, width=2 * inch,
                        height=2 * inch)
            c.drawImage('FrontRight.png', startY + 4.5 * inch, startX - 3 * lineSpacing - 2.25 * inch, width=2 * inch,
                        height=2 * inch)

            c.drawImage('BackLeft.png', startY, startX - 3 * lineSpacing - 4.5 * inch, width=2 * inch, height=2 * inch)
            c.drawImage('Back.png', startY + 2.25 * inch, startX - 3 * lineSpacing - 4.5 * inch, width=2 * inch,
                        height=2 * inch)
            c.drawImage('BackRight.png', startY + 4.5 * inch, startX - 3 * lineSpacing - 4.5 * inch, width=2 * inch,
                        height=2 * inch)
        else:
            c.setLineWidth(.5)
            c.setFont('Helvetica', 12)
            startX = height - 0.7 * inch  # Using 0.7 inch margins to fit all images
            startY = inch
            midPosition = (startY + (width - inch)) / 2

            c.drawString(startY, startX, 'Patient:')
            c.drawString(startY, startX - lineSpacing, patientName)
            c.drawString(startY, startX - 2 * lineSpacing, patientID)

            c.drawCentredString(midPosition, startX, structName)
            c.drawCentredString(midPosition, startX - lineSpacing, structMaxDose)
            c.drawCentredString(midPosition, startX - 2 * lineSpacing, maxDose)

            c.drawRightString(width - inch, startX, hospitalName)
            c.drawRightString(width - inch, startX - lineSpacing, doctorName)

            c.line(startY, startX - 3 * lineSpacing, width - inch, startX - 3 * lineSpacing)

            c.drawImage('FrontLeft.png', startY, startX - 3 * lineSpacing - 3.125 * inch, width=3 * inch,
                        height=3 * inch)
            c.drawImage('FrontRight.png', startY + 3.25 * inch, startX - 3 * lineSpacing - 3.125 * inch, width=3 * inch,
                        height=3 * inch)

            c.drawImage('Front.png', startY, startX - 3 * lineSpacing - 6.25 * inch, width=3 * inch, height=3 * inch)
            c.drawImage('Back.png', startY + 3.25 * inch, startX - 3 * lineSpacing - 6.25 * inch, width=3 * inch,
                        height=3 * inch)

            c.drawImage('BackLeft.png', startY, startX - 3 * lineSpacing - 9.375 * inch, width=3 * inch,
                        height=3 * inch)
            c.drawImage('BackRight.png', startY + 3.25 * inch, startX - 3 * lineSpacing - 9.375 * inch, width=3 * inch,
                        height=3 * inch)

        c.save()
        pdf_out = output.getvalue()
        output.close()
        # Delete the images from disk
        os.remove('Front.png')
        os.remove('FrontLeft.png')
        os.remove('FrontRight.png')
        os.remove('Back.png')
        os.remove('BackLeft.png')
        os.remove('BackRight.png')
        return pdf_out


class PlanReportCreator(object):
    def __init__(self, results_df):
        self.results_df = results_df

    def makeReport(self):
        return self.createPDF(0)  # 0 is parameter for report with big image

    # Load a struct file only. Code is similar to loadFolder()
    def loadStruct(self, filename):
        self.structFile = dicom.read_file(filename)
        if "StructureSetROISequence" in self.structFile:
            self.roiList = [roi.ROIName for roi in self.structFile.StructureSetROISequence if "ROIName" in roi]
        else:
            return "Not an RTStruct file"
        return 0

    # Load a dose file only. Code is similar to loadFolder()
    def loadDose(self, filenames):
        self.doseFile = dicom.read_file(filenames[0])

        if len(filenames) == 1:
            self.dosePixels = self.doseFile.pixel_array * self.doseFile.DoseGridScaling
        else:
            try:
                self.dosePixels = self.getSumDose(filenames)
            except ValueError:
                return "Dose grids must have the same dimensions"
        return 0

    def set_ctfile(self, filename):
        self.ctFile = filename

    def getSumDose(self, filenames):
        # Use first dose file's coordinate system
        dose_file = self.doseFile
        dose_grid = dose_file.pixel_array * dose_file.DoseGridScaling
        for dose_filename in filenames[1:]:
            sum_dose_file = dicom.read_file(dose_filename)
            dose_grid += sum_dose_file.pixel_array * sum_dose_file.DoseGridScaling

        return dose_grid

    # Generate a 3D model based on selected ROIs
    def loadModel(self, roi_numbers):
        self.roiName = self.roiList[roi_numbers[0]]

        for roi_num in roi_numbers:
            roiContours = self.structFile.ROIContourSequence[roi_num]
            if "Contours" not in roiContours:
                print("No contours found in roi_numbers")
                return

        zSpacing = abs(self.doseFile.GridFrameOffsetVector[1] - self.doseFile.GridFrameOffsetVector[0])
        firstZ = self.doseFile.ImagePositionPatient[2] - 0.5 * zSpacing

        structDict = {}
        structDict["contours"] = {}
        xArray = []
        yArray = []
        zArray = []

        # Get contour data for each roi_numbers
        for roi_num in roi_numbers:
            roiContours = self.structFile.ROIContourSequence[roi_num]
            for aContour in roiContours.ContourSequence:
                sliceNumber = int(round((aContour.ContourData[2] - firstZ) / zSpacing))
                if sliceNumber not in structDict["contours"]:
                    structDict["contours"][sliceNumber] = []
                curContour = np.array(aContour.ContourData).reshape(-1, 3)[:, 0:2]
                structDict["contours"][sliceNumber].append(Path(curContour))
                curContour = np.array(aContour.ContourData).reshape(-1, 3)
                xArray += list(curContour[:, 0])
                yArray += list(curContour[:, 1])
                zArray += list(curContour[:, 2])

        xSpacing = self.doseFile.PixelSpacing[0]
        ySpacing = self.doseFile.PixelSpacing[1]

        firstX = self.doseFile.ImagePositionPatient[0] - 0.5 * xSpacing
        firstY = self.doseFile.ImagePositionPatient[1] - 0.5 * ySpacing

        numX = self.doseFile.Columns
        numY = self.doseFile.Rows

        indices = np.indices((numY, numX))  # Not sure why indices are Y,X instead of X,Y
        xPositions = indices[1] * xSpacing + firstX
        yPositions = indices[0] * ySpacing + firstY
        positions = np.array(zip(xPositions.flatten(), yPositions.flatten()))

        doseMatrix = np.zeros(self.dosePixels.shape)
        for aSlice in structDict["contours"]:
            if aSlice < doseMatrix.shape[0]:
                for aContour in structDict["contours"][aSlice]:
                    result = aContour.contains_points(positions)
                    result = np.resize(result, self.dosePixels[aSlice].shape)
                    doseMatrix[aSlice] += self.dosePixels[aSlice] * result

        # doseMatrix = doseMatrix * self.doseFile.DoseGridScaling
        self.maxStructDose = doseMatrix.max()

        mlab.clf()
        doseValues = [self.getDoseValue(aPoint[0], aPoint[1], aPoint[2]) for aPoint in zip(xArray, yArray, zArray)]
        volume = mlab.points3d(xArray, yArray, zArray, doseValues, scale_mode="none")
        # mlab.title('Patient: %s' % patientName)
        mlab.colorbar(volume, "Dose (Gy)", nb_labels=4, orientation="horizontal", label_fmt="%2.0f")
        lut = volume.module_manager.scalar_lut_manager.lut
        lut.range = [0, self.maxStructDose]
        # self.drawSkin()     # Draw the patient body

    def getDoseValue(self, x, y, z):
        xVoxel = (x - self.doseFile.ImagePositionPatient[0]) / self.doseFile.PixelSpacing[0]
        yVoxel = (y - self.doseFile.ImagePositionPatient[1]) / self.doseFile.PixelSpacing[1]
        zSlice = (z - self.doseFile.ImagePositionPatient[2]) / (
            abs(self.doseFile.GridFrameOffsetVector[1] - self.doseFile.GridFrameOffsetVector[0]))
        if xVoxel < self.doseFile.Columns and yVoxel < self.doseFile.Rows and zSlice < len(
                self.doseFile.GridFrameOffsetVector):
            return self.dosePixels[zSlice][yVoxel][xVoxel]
        else:
            return 0

    def drawSkin(self):
        ROI = 'EXTERNAL'  # Making a guess here in assuming all body ROIs have the name 'BODY'

        # The steps are similar to loadModel(), except simpler since ROI is no longer a list
        index = self.roiList.index(ROI)
        zSpacing = abs(self.doseFile.GridFrameOffsetVector[1] - self.doseFile.GridFrameOffsetVector[0])
        firstZ = self.doseFile.ImagePositionPatient[2] - 0.5 * zSpacing

        roiContours = self.structFile.ROIContourSequence[index]
        # This should be unncessary, but it's still here for now
        if "Contours" not in roiContours:
            print("No contours found in ROI")
            return

        structDict = {}
        structDict["contours"] = {}
        xArray = []
        yArray = []
        zArray = []

        for aContour in roiContours.ContourSequence:
            sliceNumber = int(round((aContour.ContourData[2] - firstZ) / zSpacing))
            if sliceNumber not in structDict["contours"]:
                structDict["contours"][sliceNumber] = []
            curContour = np.array(aContour.ContourData).reshape(-1, 3)[:, 0:2]
            structDict["contours"][sliceNumber].append(Path(curContour))
            curContour = np.array(aContour.ContourData).reshape(-1, 3)
            xArray += list(curContour[:, 0])
            yArray += list(curContour[:, 1])
            zArray += list(curContour[:, 2])

        mlab.plot3d(xArray, yArray, zArray, color=(0, 0, 0))

    def createPDF(self, imageOrientation=1):
        # Create the PDF canvas
        c = Canvas(output, pagesize=letter)

        # Get some relevant variables
        patientName = self.doseFile.PatientName
        patientID = self.doseFile.PatientID

        structName = self.roiName
        structMaxDose = 'Max Dose to structure: %0.2f Gy' % self.maxStructDose
        maxDose = 'Max Dose to whole volume: %0.2f Gy' % (self.dosePixels.max())

        ctDicom = dicom.read_file(self.ctFile)
        hospitalName = ctDicom.InstitutionName
        doctorName = ctDicom.ReferringPhysicianName

        # Size of letter
        width, height = letter
        # Point of origin for reportlab is bottom left of page

        lineSpacing = 12

        if imageOrientation == 1:  # "Small images" option
            c.setLineWidth(.5)
            c.setFont('Helvetica', 12)

            # Use 1 inch margins
            startX = height - inch
            startY = inch

            midPosition = (startY + (width - inch)) / 2  # The midline of the page

            # Top left text of the page (Patient Info)
            c.drawString(startY, startX, 'Patient:')
            c.drawString(startY, startX - lineSpacing, patientName)
            c.drawString(startY, startX - 2 * lineSpacing, patientID)

            # Top middle text of the page (ROI info)
            c.drawCentredString(midPosition, startX, structName)
            c.drawCentredString(midPosition, startX - lineSpacing, structMaxDose)
            c.drawCentredString(midPosition, startX - 2 * lineSpacing, maxDose)

            # Top right text of the page (Institution/Doctor name)
            c.drawRightString(width - inch, startX, hospitalName)
            c.drawRightString(width - inch, startX - lineSpacing, doctorName)

            # Draw a line to seperate text from images
            c.line(startY, startX - 3 * lineSpacing, width - inch, startX - 3 * lineSpacing)

            # Draw the images
            c.drawImage('FrontLeft.png', startY, startX - 3 * lineSpacing - 2.25 * inch, width=2 * inch,
                        height=2 * inch)
            c.drawImage('Front.png', startY + 2.25 * inch, startX - 3 * lineSpacing - 2.25 * inch, width=2 * inch,
                        height=2 * inch)
            c.drawImage('FrontRight.png', startY + 4.5 * inch, startX - 3 * lineSpacing - 2.25 * inch, width=2 * inch,
                        height=2 * inch)

            c.drawImage('BackLeft.png', startY, startX - 3 * lineSpacing - 4.5 * inch, width=2 * inch, height=2 * inch)
            c.drawImage('Back.png', startY + 2.25 * inch, startX - 3 * lineSpacing - 4.5 * inch, width=2 * inch,
                        height=2 * inch)
            c.drawImage('BackRight.png', startY + 4.5 * inch, startX - 3 * lineSpacing - 4.5 * inch, width=2 * inch,
                        height=2 * inch)
        else:
            c.setLineWidth(.5)
            c.setFont('Helvetica', 12)
            startX = height - 0.7 * inch  # Using 0.7 inch margins to fit all images
            startY = inch
            midPosition = (startY + (width - inch)) / 2

            c.drawString(startY, startX, 'Patient:')
            c.drawString(startY, startX - lineSpacing, patientName)
            c.drawString(startY, startX - 2 * lineSpacing, patientID)

            c.drawCentredString(midPosition, startX, structName)
            c.drawCentredString(midPosition, startX - lineSpacing, structMaxDose)
            c.drawCentredString(midPosition, startX - 2 * lineSpacing, maxDose)

            c.drawRightString(width - inch, startX, hospitalName)
            c.drawRightString(width - inch, startX - lineSpacing, doctorName)

            c.line(startY, startX - 3 * lineSpacing, width - inch, startX - 3 * lineSpacing)

            c.drawImage('FrontLeft.png', startY, startX - 3 * lineSpacing - 3.125 * inch, width=3 * inch,
                        height=3 * inch)
            c.drawImage('FrontRight.png', startY + 3.25 * inch, startX - 3 * lineSpacing - 3.125 * inch, width=3 * inch,
                        height=3 * inch)

            c.drawImage('Front.png', startY, startX - 3 * lineSpacing - 6.25 * inch, width=3 * inch, height=3 * inch)
            c.drawImage('Back.png', startY + 3.25 * inch, startX - 3 * lineSpacing - 6.25 * inch, width=3 * inch,
                        height=3 * inch)

            c.drawImage('BackLeft.png', startY, startX - 3 * lineSpacing - 9.375 * inch, width=3 * inch,
                        height=3 * inch)
            c.drawImage('BackRight.png', startY + 3.25 * inch, startX - 3 * lineSpacing - 9.375 * inch, width=3 * inch,
                        height=3 * inch)

        c.save()
        pdf_out = output.getvalue()
        output.close()
        # Delete the images from disk
        os.remove('Front.png')
        os.remove('FrontLeft.png')
        os.remove('FrontRight.png')
        os.remove('Back.png')
        os.remove('BackLeft.png')
        os.remove('BackRight.png')

        return pdf_out


def main():
    rep = ReportCreator()
    rep.loadDose("RD.1.2.246.352.71.7.1217694584.904860.20131230102104.dcm")
    rep.loadStruct("RS.1.2.246.352.71.4.228044388791.151911.20141030132135.dcm")
    rep.set_ctfile("CT.1.2.840.113619.2.55.3.2198498030.508.1387194417.426.1.dcm")
    rep.loadModel([10])
    rep.makeReport()


if __name__ == "__main__":
    main()
