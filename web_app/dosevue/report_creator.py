import os

import pandas as pd
from xlsxwriter.utility import xl_rowcol_to_cell

from pyplanscoring.dicomparser import ScoringDicomParser
from pyplanscoring.dosimetric import read_scoring_criteria
from pyplanscoring.scoring import Participant

os.environ['ETS_TOOLKIT'] = 'wx'
import dicom
import numpy as np

# Needed for Mayavi 3d rendering
from matplotlib.path import Path
from mayavi import mlab

# Needed for creating the pdf report
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen.canvas import Canvas
from reportlab.lib.units import inch

import sys

if sys.version[0] == '2':
    import cStringIO

    output = cStringIO.StringIO()
else:
    # python3.4
    from io import StringIO

    output = StringIO()


#######################################################################
##### Main program
class ReportCreator():
    def __init__(self):
        mlab.options.offscreen = True
        # pass

    # Create and save the images from 6 views
    def makeReport(self):
        res = 512  # Resolution of image. Currently using 270x270 for speed.
        curView = mlab.view()  # Get the current camera orientation
        distance = curView[2] * 0.7  # We're mostly interested in the distance (zoom)
        curPosition, curFoc = mlab.move()  # Get the current camera position (we only want focal point)

        # The six views are generated by rotating the camera
        # The distance (zoom) and focal point of the user's view is perserved
        mlab.view(45, 90, distance, curFoc)
        mlab.savefig('BackLeft.png', size=(res, res))
        mlab.view(90, 90, distance, curFoc)
        mlab.savefig('Back.png', size=(res, res))
        mlab.view(135, 90, distance, curFoc)
        mlab.savefig('BackRight.png', size=(res, res))
        mlab.view(315, 90, distance, curFoc)
        mlab.savefig('FrontLeft.png', size=(res, res))
        mlab.view(270, 90, distance, curFoc)
        mlab.savefig('Front.png', size=(res, res))
        mlab.view(225, 90, distance, curFoc)
        mlab.savefig('FrontRight.png', size=(res, res))

        return self.createPDF(0)  # 0 is parameter for report with big image

    # Load a struct file only. Code is similar to loadFolder()
    def loadStruct(self, filename):
        self.structFile = dicom.read_file(filename)
        if "StructureSetROISequence" in self.structFile:
            self.roiList = [roi.ROIName for roi in self.structFile.StructureSetROISequence if "ROIName" in roi]
        else:
            return "Not an RTStruct file"
        return 0

    # Load a dose file only. Code is similar to loadFolder()
    def loadDose(self, filenames):
        self.doseFile = dicom.read_file(filenames[0])

        if len(filenames) == 1:
            self.dosePixels = self.doseFile.pixel_array * self.doseFile.DoseGridScaling
        else:
            try:
                self.dosePixels = self.getSumDose(filenames)
            except ValueError:
                return "Dose grids must have the same dimensions"
        return 0

    def set_ctfile(self, filename):
        self.ctFile = filename

    def getSumDose(self, filenames):
        # Use first dose file's coordinate system
        dose_file = self.doseFile
        dose_grid = dose_file.pixel_array * dose_file.DoseGridScaling
        for dose_filename in filenames[1:]:
            sum_dose_file = dicom.read_file(dose_filename)
            dose_grid += sum_dose_file.pixel_array * sum_dose_file.DoseGridScaling

        return dose_grid

    # Generate a 3D model based on selected ROIs
    def loadModel(self, roi_numbers):
        self.roiName = self.roiList[roi_numbers[0]]

        for roi_num in roi_numbers:
            roiContours = self.structFile.ROIContourSequence[roi_num]
            if "Contours" not in roiContours:
                print("No contours found in roi_numbers")
                return

        zSpacing = abs(self.doseFile.GridFrameOffsetVector[1] - self.doseFile.GridFrameOffsetVector[0])
        firstZ = self.doseFile.ImagePositionPatient[2] - 0.5 * zSpacing

        structDict = {}
        structDict["contours"] = {}
        xArray = []
        yArray = []
        zArray = []

        # Get contour data for each roi_numbers
        for roi_num in roi_numbers:
            roiContours = self.structFile.ROIContourSequence[roi_num]
            for aContour in roiContours.ContourSequence:
                sliceNumber = int(round((aContour.ContourData[2] - firstZ) / zSpacing))
                if sliceNumber not in structDict["contours"]:
                    structDict["contours"][sliceNumber] = []
                curContour = np.array(aContour.ContourData).reshape(-1, 3)[:, 0:2]
                structDict["contours"][sliceNumber].append(Path(curContour))
                curContour = np.array(aContour.ContourData).reshape(-1, 3)
                xArray += list(curContour[:, 0])
                yArray += list(curContour[:, 1])
                zArray += list(curContour[:, 2])

        xSpacing = self.doseFile.PixelSpacing[0]
        ySpacing = self.doseFile.PixelSpacing[1]

        firstX = self.doseFile.ImagePositionPatient[0] - 0.5 * xSpacing
        firstY = self.doseFile.ImagePositionPatient[1] - 0.5 * ySpacing

        numX = self.doseFile.Columns
        numY = self.doseFile.Rows

        indices = np.indices((numY, numX))  # Not sure why indices are Y,X instead of X,Y
        xPositions = indices[1] * xSpacing + firstX
        yPositions = indices[0] * ySpacing + firstY
        positions = np.array(zip(xPositions.flatten(), yPositions.flatten()))

        doseMatrix = np.zeros(self.dosePixels.shape)
        for aSlice in structDict["contours"]:
            if aSlice < doseMatrix.shape[0]:
                for aContour in structDict["contours"][aSlice]:
                    result = aContour.contains_points(positions)
                    result = np.resize(result, self.dosePixels[aSlice].shape)
                    doseMatrix[aSlice] += self.dosePixels[aSlice] * result

        # doseMatrix = doseMatrix * self.doseFile.DoseGridScaling
        self.maxStructDose = doseMatrix.max()

        mlab.clf()
        doseValues = [self.getDoseValue(aPoint[0], aPoint[1], aPoint[2]) for aPoint in zip(xArray, yArray, zArray)]
        volume = mlab.points3d(xArray, yArray, zArray, doseValues, scale_mode="none")
        # mlab.title('Patient: %s' % patientName)
        mlab.colorbar(volume, "Dose (Gy)", nb_labels=4, orientation="horizontal", label_fmt="%2.0f")
        lut = volume.module_manager.scalar_lut_manager.lut
        lut.range = [0, self.maxStructDose]
        # self.drawSkin()     # Draw the patient body

    def getDoseValue(self, x, y, z):
        xVoxel = (x - self.doseFile.ImagePositionPatient[0]) / self.doseFile.PixelSpacing[0]
        yVoxel = (y - self.doseFile.ImagePositionPatient[1]) / self.doseFile.PixelSpacing[1]
        zSlice = (z - self.doseFile.ImagePositionPatient[2]) / (
            abs(self.doseFile.GridFrameOffsetVector[1] - self.doseFile.GridFrameOffsetVector[0]))
        if xVoxel < self.doseFile.Columns and yVoxel < self.doseFile.Rows and zSlice < len(
                self.doseFile.GridFrameOffsetVector):
            return self.dosePixels[zSlice][yVoxel][xVoxel]
        else:
            return 0

    def drawSkin(self):
        ROI = 'EXTERNAL'  # Making a guess here in assuming all body ROIs have the name 'BODY'

        # The steps are similar to loadModel(), except simpler since ROI is no longer a list
        index = self.roiList.index(ROI)
        zSpacing = abs(self.doseFile.GridFrameOffsetVector[1] - self.doseFile.GridFrameOffsetVector[0])
        firstZ = self.doseFile.ImagePositionPatient[2] - 0.5 * zSpacing

        roiContours = self.structFile.ROIContourSequence[index]
        # This should be unncessary, but it's still here for now
        if "Contours" not in roiContours:
            print("No contours found in ROI")
            return

        structDict = {}
        structDict["contours"] = {}
        xArray = []
        yArray = []
        zArray = []

        for aContour in roiContours.ContourSequence:
            sliceNumber = int(round((aContour.ContourData[2] - firstZ) / zSpacing))
            if sliceNumber not in structDict["contours"]:
                structDict["contours"][sliceNumber] = []
            curContour = np.array(aContour.ContourData).reshape(-1, 3)[:, 0:2]
            structDict["contours"][sliceNumber].append(Path(curContour))
            curContour = np.array(aContour.ContourData).reshape(-1, 3)
            xArray += list(curContour[:, 0])
            yArray += list(curContour[:, 1])
            zArray += list(curContour[:, 2])

        mlab.plot3d(xArray, yArray, zArray, color=(0, 0, 0))

    def createPDF(self, imageOrientation=1):
        # python3.4
        # from io import StringI
        # output = StringIO()
        # Python 2.7
        # import cStringIO
        # output = cStringIO.StringIO()

        # Create the PDF canvas
        c = Canvas(output, pagesize=letter)

        # Get some relevant variables
        patientName = self.doseFile.PatientName
        patientID = self.doseFile.PatientID

        structName = self.roiName
        structMaxDose = 'Max Dose to structure: %0.2f Gy' % self.maxStructDose
        maxDose = 'Max Dose to whole volume: %0.2f Gy' % (self.dosePixels.max())

        ctDicom = dicom.read_file(self.ctFile)
        hospitalName = ctDicom.InstitutionName
        doctorName = ctDicom.ReferringPhysicianName

        # Size of letter
        width, height = letter
        # Point of origin for reportlab is bottom left of page

        lineSpacing = 12

        if imageOrientation == 1:  # "Small images" option
            c.setLineWidth(.5)
            c.setFont('Helvetica', 12)

            # Use 1 inch margins
            startX = height - inch
            startY = inch

            midPosition = (startY + (width - inch)) / 2  # The midline of the page

            # Top left text of the page (Patient Info)
            c.drawString(startY, startX, 'Patient:')
            c.drawString(startY, startX - lineSpacing, patientName)
            c.drawString(startY, startX - 2 * lineSpacing, patientID)

            # Top middle text of the page (ROI info)
            c.drawCentredString(midPosition, startX, structName)
            c.drawCentredString(midPosition, startX - lineSpacing, structMaxDose)
            c.drawCentredString(midPosition, startX - 2 * lineSpacing, maxDose)

            # Top right text of the page (Institution/Doctor name)
            c.drawRightString(width - inch, startX, hospitalName)
            c.drawRightString(width - inch, startX - lineSpacing, doctorName)

            # Draw a line to seperate text from images
            c.line(startY, startX - 3 * lineSpacing, width - inch, startX - 3 * lineSpacing)

            # Draw the images
            c.drawImage('FrontLeft.png', startY, startX - 3 * lineSpacing - 2.25 * inch, width=2 * inch,
                        height=2 * inch)
            c.drawImage('Front.png', startY + 2.25 * inch, startX - 3 * lineSpacing - 2.25 * inch, width=2 * inch,
                        height=2 * inch)
            c.drawImage('FrontRight.png', startY + 4.5 * inch, startX - 3 * lineSpacing - 2.25 * inch, width=2 * inch,
                        height=2 * inch)

            c.drawImage('BackLeft.png', startY, startX - 3 * lineSpacing - 4.5 * inch, width=2 * inch, height=2 * inch)
            c.drawImage('Back.png', startY + 2.25 * inch, startX - 3 * lineSpacing - 4.5 * inch, width=2 * inch,
                        height=2 * inch)
            c.drawImage('BackRight.png', startY + 4.5 * inch, startX - 3 * lineSpacing - 4.5 * inch, width=2 * inch,
                        height=2 * inch)
        else:
            c.setLineWidth(.5)
            c.setFont('Helvetica', 12)
            startX = height - 0.7 * inch  # Using 0.7 inch margins to fit all images
            startY = inch
            midPosition = (startY + (width - inch)) / 2

            c.drawString(startY, startX, 'Patient:')
            c.drawString(startY, startX - lineSpacing, patientName)
            c.drawString(startY, startX - 2 * lineSpacing, patientID)

            c.drawCentredString(midPosition, startX, structName)
            c.drawCentredString(midPosition, startX - lineSpacing, structMaxDose)
            c.drawCentredString(midPosition, startX - 2 * lineSpacing, maxDose)

            c.drawRightString(width - inch, startX, hospitalName)
            c.drawRightString(width - inch, startX - lineSpacing, doctorName)

            c.line(startY, startX - 3 * lineSpacing, width - inch, startX - 3 * lineSpacing)

            c.drawImage('FrontLeft.png', startY, startX - 3 * lineSpacing - 3.125 * inch, width=3 * inch,
                        height=3 * inch)
            c.drawImage('FrontRight.png', startY + 3.25 * inch, startX - 3 * lineSpacing - 3.125 * inch, width=3 * inch,
                        height=3 * inch)

            c.drawImage('Front.png', startY, startX - 3 * lineSpacing - 6.25 * inch, width=3 * inch, height=3 * inch)
            c.drawImage('Back.png', startY + 3.25 * inch, startX - 3 * lineSpacing - 6.25 * inch, width=3 * inch,
                        height=3 * inch)

            c.drawImage('BackLeft.png', startY, startX - 3 * lineSpacing - 9.375 * inch, width=3 * inch,
                        height=3 * inch)
            c.drawImage('BackRight.png', startY + 3.25 * inch, startX - 3 * lineSpacing - 9.375 * inch, width=3 * inch,
                        height=3 * inch)

        c.save()
        pdf_out = output.getvalue()
        output.close()
        # Delete the images from disk
        os.remove('Front.png')
        os.remove('FrontLeft.png')
        os.remove('FrontRight.png')
        os.remove('Back.png')
        os.remove('BackLeft.png')
        os.remove('BackRight.png')
        return pdf_out


class PlanReportCreator(object):
    def __init__(self):
        self.results_df = None
        self.rp_file = ''
        self.rs_file = ''
        self.rd_file = ''
        self.rp_dcm = None
        self.rs_dcm = None
        self.rd_dcm = None

    # Load a struct file only. Code is similar to loadFolder()
    def loadStruct(self, filename):
        obj = ScoringDicomParser(filename=filename)
        if obj.GetSOPClassUID() != 'rtss':
            return "Not an RTStruct file"
        else:
            self.rs_file = filename
            self.rs_dcm = obj
            return 0

    # Load a dose file only. Code is similar to loadFolder()
    def loadDose(self, filename):
        obj = ScoringDicomParser(filename=filename)
        if obj.GetSOPClassUID() != 'rtdose':
            return "Not an RTDose file"
        else:
            self.rd_file = filename
            self.rd_dcm = obj
            return 0

    def load_plan(self, filename):
        # Load a dose file only. Code is similar to loadFolder()
        obj = ScoringDicomParser(filename=filename)
        if obj.GetSOPClassUID() != 'rtplan':
            return "Not an RTPlan file"
        else:
            self.rp_file = filename
            self.rp_dcm = obj
            return 0

    def makeReport(self, f, banner_path='', report_header=''):
        participant_name = ''
        constrains, scores, criteria = read_scoring_criteria(f)

        # Set calculation options
        calculation_options = dict()
        calculation_options['end_cap'] = 0.5
        calculation_options['use_tps_dvh'] = False
        calculation_options['up_sampling'] = True
        calculation_options['maximum_upsampled_volume_cc'] = 100.0
        calculation_options['voxel_size'] = 0.5

        print('------------- Calculating DVH and score --------------')

        participant = Participant(self.rp_file, self.rs_file, self.rd_file, calculation_options=calculation_options)
        participant.set_participant_data(participant_name)
        val = participant.eval_score(constrains_dict=constrains, scores_dict=scores, criteria_df=criteria,
                                     calculation_options=calculation_options)

        print('Plan Score: %1.2f' % val)
        participant.get_score_report(banner_path, report_header, output)

        xlsx_out = output.getvalue()
        output.close()

        return xlsx_out

    def create_excel(self):
        pass

    def createPDF(self, data):
        # Create the PDF canvas
        c = Canvas(output, pagesize=letter)

        # Get some relevant variables
        patientName = self.rd_dcm.ds.PatientName
        patientID = self.rd_dcm.ds.PatientID

        structName = ''
        structMaxDose = 'Max Dose to structure'
        maxDose = 'Max Dose to whole volume: '

        hospitalName = ''
        doctorName = ''

        # Size of letter
        width, height = letter
        # Point of origin for reportlab is bottom left of page

        lineSpacing = 12

        c.setLineWidth(.5)
        c.setFont('Helvetica', 12)

        # Use 1 inch margins
        startX = height - inch
        startY = inch

        midPosition = (startY + (width - inch)) / 2  # The midline of the page

        # Top left text of the page (Patient Info)
        c.drawString(startY, startX, data)

        # c.drawString(startY, startX - lineSpacing, patientName)
        # c.drawString(startY, startX - 2 * lineSpacing, patientID)
        #
        # # Top middle text of the page (ROI info)
        # c.drawCentredString(midPosition, startX, structName)
        # c.drawCentredString(midPosition, startX - lineSpacing, structMaxDose)
        # c.drawCentredString(midPosition, startX - 2 * lineSpacing, maxDose)
        #
        # # Top right text of the page (Institution/Doctor name)
        # c.drawRightString(width - inch, startX, hospitalName)
        # c.drawRightString(width - inch, startX - lineSpacing, doctorName)
        #
        # # Draw a line to seperate text from images
        # c.line(startY, startX - 3 * lineSpacing, width - inch, startX - 3 * lineSpacing)

        # Draw the table

        c.save()
        pdf_out = output.getvalue()
        output.close()

        return pdf_out

    @staticmethod
    def save_formatted_report(df, out_file, banner_path=None, report_header='', io=None):

        """
            Save an formated report using pandas and xlsxwriter
        :param df: Results dataframe
        :param out_file: filename path
        :param banner_path: banner path

        """

        # Even though the final file will be in memory the module uses temp
        # files during assembly for efficiency. To avoid this on servers that
        # don't allow temp files, for example the Google APP Engine, set the
        # 'in_memory' constructor option to True:
        workbook = xlsxwriter.Workbook(output, {'in_memory': True})
        worksheet = workbook.add_worksheet()

        start_row = 31
        number_rows = len(df.index)
        writer = pd.ExcelWriter(output, 'xlsxwriter', {'in_memory': True})

        df.to_excel(writer, sheet_name='report', startrow=start_row)

        # Get access to the workbook and sheet
        workbook = writer.book
        worksheet = writer.sheets['report']

        # Reduce the zoom a little
        worksheet.set_zoom(65)
        # constrain_fmt = workbook.add_format({'align': 'center'})
        constrain_fmt = workbook.add_format({'align': 'center'})

        # # Total formatting
        number_format = workbook.add_format({'align': 'right', 'num_format': '0.00'})
        # # Total percent format
        total_percent_fmt = workbook.add_format({'align': 'right', 'num_format': '0.0%', 'bold': True})

        # Add a format. Light red fill with dark red text.
        format1 = workbook.add_format({'bg_color': '#FFC7CE',
                                       'font_color': '#9C0006'})

        # Add a format. Green fill with dark green text.
        format2 = workbook.add_format({'bg_color': '#C6EFCE',
                                       'font_color': '#006100'})

        # Format the columns by width and include number formats

        # Structure name
        nr = number_rows + start_row
        sname = "A2:A{}".format(nr + 1)
        worksheet.set_column(sname, 24)
        # constrain
        constrain = "B2:B{}".format(nr + 1)
        worksheet.set_column(constrain, 20, constrain_fmt)

        # constrain value
        constrain_value = "C2:C{}".format(nr + 1)
        worksheet.set_column(constrain_value, 20, constrain_fmt)

        # constrain type
        constrain_type = "D2:D{}".format(nr + 1)
        worksheet.set_column(constrain_type, 20, constrain_fmt)

        worksheet.conditional_format(constrain_type, {'type': 'text',
                                                      'criteria': 'containing',
                                                      'value': 'upper',
                                                      'format': format1})

        # Highlight the bottom 5 values in Red
        worksheet.conditional_format(constrain_type, {'type': 'text',
                                                      'criteria': 'containing',
                                                      'value': 'lower',
                                                      'format': format2})

        # value low and high
        worksheet.set_column('E:I', 20, number_format)

        # Define our range for the color formatting
        color_range = "J2:J{}".format(nr + 1)
        worksheet.set_column(color_range, 20, total_percent_fmt)

        # Highlight the top 5 values in Green
        worksheet.conditional_format(color_range, {'type': 'data_bar'})

        # write total score rows
        total_fmt = workbook.add_format({'align': 'right', 'num_format': '0.00',
                                         'bold': True, 'bottom': 6})

        total_fmt_header = workbook.add_format({'align': 'right', 'num_format': '0.00',
                                                'bold': True, 'bottom': 6, 'bg_color': '#C6EFCE'})

        total_score = df['Raw Score'].sum()
        max_score = df['Max Score'].sum()
        performance = total_score / max_score

        worksheet.write_string(nr + 1, 5, "Max Score:", total_fmt)
        worksheet.write_string(nr + 1, 7, "Total Score:", total_fmt_header)

        # performance format
        performance_format = workbook.add_format(
            {'align': 'right', 'num_format': '0.0%', 'bold': True, 'bottom': 6, 'bg_color': '#C6EFCE'})

        cell_location = xl_rowcol_to_cell(nr + 1, 9)
        worksheet.write_number(cell_location, performance, performance_format)

        cell_location = xl_rowcol_to_cell(nr + 1, 6)
        # Get the range to use for the sum formula
        worksheet.write_number(cell_location, max_score, total_fmt)
        cell_location = xl_rowcol_to_cell(nr + 1, 8)
        worksheet.write_number(cell_location, total_score, total_fmt_header)

        # SAVE BANNER
        if banner_path is not None:
            options = {'x_scale': 0.87}
        worksheet.insert_image('A1', banner_path, options=options)

        # adding participant header
        # Create a format to use in the merged range.
        merge_format = workbook.add_format({
            'bold': 1,
            'border': 1,
            'align': 'center',
            'valign': 'vcenter',
            'font_size': 15,
        })

        # Merge 3 cells.
        worksheet.merge_range('A31:J31', report_header, merge_format)

        writer.save()


def main():
    rep = ReportCreator()
    rep.loadDose("RD.1.2.246.352.71.7.1217694584.904860.20131230102104.dcm")
    rep.loadStruct("RS.1.2.246.352.71.4.228044388791.151911.20141030132135.dcm")
    rep.set_ctfile("CT.1.2.840.113619.2.55.3.2198498030.508.1387194417.426.1.dcm")
    rep.loadModel([10])
    rep.makeReport()


if __name__ == "__main__":
    rep = PlanReportCreator()
    rs = '/home/victor/Dropbox/Plan_Competition_Project/competition_2017/DICOM/RS.1.2.246.352.71.4.584747638204.253443.20170222200317.dcm'
    rd = '/home/victor/Dropbox/Plan_Competition_Project/competition_2017/plans/Ahmad Nobah/RD.1.2.246.352.71.7.584747638204.1758320.20170210154830.dcm'
    rep.load_dose(rd)
    rep.load_struct(rs)
    # rep.loadModel([10])
    # rep.makeReport()

    constrains, scores, criteria = read_scoring_criteria(f)

    calculation_options = dict()
    calculation_options['end_cap'] = 0.2
    calculation_options['use_tps_dvh'] = False
    calculation_options['up_sampling'] = True
    calculation_options['maximum_upsampled_volume_cc'] = 100.0
    calculation_options['voxel_size'] = 0.2

    print('------------- Calculating DVH and score --------------')

    participant = Participant(rp, rs, rd, calculation_options=calculation_options)
    participant.set_participant_data(participant_name)
    val = participant.eval_score(constrains_dict=constrains, scores_dict=scores, criteria_df=criteria,
                                 calculation_options=calculation_options)
    print(val)

    print('Plan Score: %1.3f' % val)
    out_file = os.path.join(dicom_dir, participant_name + '_plan_scoring_report.xls')
    banner_path = '/home/victor/Dropbox/Plan_Competition_Project/scoring_report/2017 Plan Comp Banner.jpg'
    participant.save_score(out_file, banner_path=banner_path)
    print('Report saved: %s' % out_file)
    input("Press enter to exit.")
